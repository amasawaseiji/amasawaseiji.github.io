<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="天泽圣司"><title>算法入门【算法图解】 · 思过崖</title><meta name="description" content="看的第一本算法书，图很多，讲的很详细，不过觉得讲的有点浅，像是专门给还不是程序员的人看的。
二分查找输入一个有序的列表和一个元素，如果元素包含的列表中返回元素的位置，否则返回null。一般，对于包含n个元素的列表，二分查找需要log2n步，简单查找最多需要n步。
大O表示法，指出了算法运行时间的增速"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">思过崖</a></h3><div class="description"><p>日常记录</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/2656331642"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"></a></li></div><div class="avatar"><img src="/asset/avatar.JPG"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>算法入门【算法图解】</a></h3></div><div class="post-content"><p>看的第一本算法书，图很多，讲的很详细，不过觉得讲的有点浅，像是专门给还不是程序员的人看的。</p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>输入一个有序的列表和一个元素，如果元素包含的列表中返回元素的位置，否则返回null。一般，对于包含n个元素的列表，二分查找需要log2n步，简单查找最多需要n步。</p>
<p>大O表示法，指出了算法运行时间的增速。二分查找表示为O(logn)，括号中叫做操作数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"></div><div class="line"><span class="comment">// Note: If you aren’t familiar with Comparable, please check out “Generics” chapter in Swift book</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span> &lt;T: Comparable&gt;<span class="params">(<span class="number">_</span> list: [T], item: T)</span></span> -&gt; <span class="type">Int</span>? &#123;</div><div class="line">    <span class="comment">// low and high keep track of which part of the list you'll search in.</span></div><div class="line">    <span class="keyword">var</span> low = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> high = list.<span class="built_in">count</span> - <span class="number">1</span></div><div class="line">    <span class="comment">// While you haven't narrowed it down to one element ...</span></div><div class="line">    <span class="keyword">while</span> low &lt;= high &#123;</div><div class="line">        <span class="comment">//... check the middle element</span></div><div class="line">        <span class="keyword">let</span> mid = low + (high - low) / <span class="number">2</span></div><div class="line">        <span class="keyword">let</span> guess = list[mid]</div><div class="line">        <span class="comment">// Found the item.</span></div><div class="line">        <span class="keyword">if</span> guess == item &#123;</div><div class="line">            <span class="keyword">return</span> mid</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// The guess was too high.</span></div><div class="line">        <span class="keyword">if</span> guess &gt; item &#123;</div><div class="line">            high = mid - <span class="number">1</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            low = mid + <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myList = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</div><div class="line"><span class="built_in">print</span>(binarySearch(myList, item: <span class="number">3</span>) ?? <span class="string">"Not Found"</span>) <span class="comment">// =&gt; 1</span></div><div class="line"><span class="built_in">print</span>(binarySearch(myList, item: -<span class="number">1</span>) ?? <span class="string">"Not Found"</span>) <span class="comment">// =&gt; Not Found</span></div></pre></td></tr></table></figure>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>数组预留位置是一种权变措施，可能浪费内存，超过这个值，需要转移。链表元素的内存可以在任何地方，数组是连续内存。链表每个元素存储了下一个元素的位置，链表的优势在插入元素方面，查找元素链表效率低。O(n)叫线性时间，O(1)叫常量时间。删除链表也是优势。数组可以随机访问，链表顺序访问。</p>
<p>选择排序速度不是很快，运行时间为O(n2)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"></div><div class="line"><span class="comment">// Finds the smallest value in an array</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSmallestIndex</span> &lt;T: Comparable&gt; <span class="params">(<span class="number">_</span> arr: [T])</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="comment">// Stores the smallest value</span></div><div class="line">    <span class="keyword">var</span> smallest = arr[<span class="number">0</span>]</div><div class="line">    <span class="comment">// We don't need any calculation if the array lenght is 1</span></div><div class="line">    <span class="keyword">if</span> arr.<span class="built_in">count</span> == <span class="number">1</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Stores the index of the smallest value</span></div><div class="line">    <span class="keyword">var</span> smallestIndex = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...arr.<span class="built_in">count</span>-<span class="number">1</span> &#123;</div><div class="line">        <span class="keyword">if</span> arr[i] &lt; smallest &#123;</div><div class="line">            smallest = arr[i]</div><div class="line">            smallestIndex = i</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> smallestIndex</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Sort array</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectionSort</span> &lt;T: Comparable&gt; <span class="params">(arr: [T])</span></span> -&gt; [<span class="type">T</span>] &#123;</div><div class="line">    <span class="keyword">var</span> newArr: [<span class="type">T</span>] = []</div><div class="line">    <span class="comment">// We have to make mutableArray reference copy of original array, because Swift 3 doesn't allow to get var parameter</span></div><div class="line">    <span class="keyword">var</span> mutableArr = arr</div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>...mutableArr.<span class="built_in">count</span>-<span class="number">1</span> &#123;</div><div class="line">       <span class="comment">//Finds the smallest element in the array and adds it to the new array</span></div><div class="line">        <span class="keyword">let</span> smallestIndex = findSmallestIndex(mutableArr)</div><div class="line">        newArr.append(mutableArr[smallestIndex])</div><div class="line">        mutableArr.remove(at: smallestIndex)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newArr</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(selectionSort(arr: [<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">10</span>])) <span class="comment">// =&gt; [2, 3, 5, 6, 10]</span></div></pre></td></tr></table></figure>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归函数有基线条件和递归条件，基线条件指的是函数不再调用自己，避免无限循环。递归指的是调用自己。</p>
<p><strong>尾递归</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">fact</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">if</span> x == <span class="number">1</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> x*fact(x: x-<span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">print</span>(fact(x: <span class="number">5</span>)) <span class="comment">// =&gt; 120</span></div></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>分而治之D&amp;C，递归式解决方法。</p>
<p><strong>欧几里得算法</strong></p>
<p>涉及数组的递归基线条件通常是数组为空或只有一个元素。</p>
<p><strong>Haskell</strong>，使用递归多，函数式编程。</p>
<p>快速排序比选择排序快，平均运行时间为O(nlogn)，也是最佳时间，每次都随机选择一个元素作为基准值就可以。</p>
<p><strong>合并排序或者也叫归并排序</strong> 也是O(nlogn)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"></div><div class="line"><span class="comment">//The following implementation of quick sort is little more classic than described in the book, but we have two use this one because of some “slice” feature limitation with array on Swift 3. Main concept is the same</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">quicksort</span> &lt;T : Comparable&gt; <span class="params">(<span class="number">_</span> array : [T])</span></span> -&gt; [<span class="type">T</span>] &#123;</div><div class="line">    <span class="keyword">if</span> (array.<span class="built_in">count</span> &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="comment">// base case, arrays with 0 or 1 element are already "sorted"</span></div><div class="line">        <span class="keyword">return</span> array</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// recursive case</span></div><div class="line">        <span class="keyword">let</span> pivot = array[<span class="number">0</span>]</div><div class="line">        <span class="comment">// sub-array of all the elements less than the pivot</span></div><div class="line">        <span class="keyword">let</span> less = array.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &lt; pivot &#125;</div><div class="line">        <span class="comment">// sub-array of all the elements equal to the pivot</span></div><div class="line">        <span class="keyword">let</span> <span class="built_in">equal</span> = array.<span class="built_in">filter</span> &#123; $<span class="number">0</span> == pivot &#125;</div><div class="line">        <span class="comment">// sub-array of all the elements greater than the pivot</span></div><div class="line">        <span class="keyword">let</span> greater = array.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &gt; pivot &#125;</div><div class="line">        <span class="keyword">return</span> quicksort(less) + <span class="built_in">equal</span> + quicksort(greater)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(quicksort([<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>, <span class="number">16</span>, <span class="number">1</span>])) <span class="comment">// =&gt; [1, 1, 5, 10, 16, 25]</span></div></pre></td></tr></table></figure>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>散列表、散列映射、映射、字典、关联数组，不同的叫法一个概念。应用DNS解析、网页缓存。2个键映射到同一个位置，给这个位置用链表。散列函数将键均匀映射到不同位置，避免冲突。插入删除与链表一样快，查找与数组一样快。填装因子度量的是散列表中的空闲位置，填装因子变大，需要调整长度，通常将数组长度增大一倍。填装因子大于0.7就需要扩增散列表长度。</p>
<p><strong>SHA函数</strong> 用作散列函数。</p>
<h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>最短路径问题，用于图查找。运行时间为O(V+E)，V是顶点，E为边数。</p>
<p>队列FIFO，栈LIFO。</p>
<p>有向图，无向图。有依赖关系，叫拓扑排序。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"></div><div class="line"><span class="comment">// As I can see Swift doesn't have Queue default implementation, so we have to use custom on, Degue structure from Swift Algorithm Club</span></div><div class="line"><span class="comment">// https://github.com/raywenderlich/swift-algorithm-club/tree/master/Deque</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Deque</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> array = [<span class="type">T</span>]()</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> array.isEmpty</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> array.<span class="built_in">count</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">enqueue</span><span class="params">(<span class="number">_</span> element: T)</span></span> &#123;</div><div class="line">        array.append(element)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">enqueueFront</span><span class="params">(<span class="number">_</span> element: T)</span></span> &#123;</div><div class="line">        array.insert(element, at: <span class="number">0</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">dequeue</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</div><div class="line">        <span class="keyword">if</span> isEmpty &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> array.removeFirst()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">dequeueBack</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</div><div class="line">        <span class="keyword">if</span> isEmpty &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> array.removeLast()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">peekFront</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</div><div class="line">        <span class="keyword">return</span> array.first</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">peekBack</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</div><div class="line">        <span class="keyword">return</span> array.last</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">persionIsSeller</span><span class="params">(name: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> name.characters.last == <span class="string">"m"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> graph = [<span class="type">String</span> : [<span class="type">String</span>]]()</div><div class="line">graph[<span class="string">"you"</span>] = [<span class="string">"alice"</span>, <span class="string">"bob"</span>, <span class="string">"claire"</span>]</div><div class="line">graph[<span class="string">"bob"</span>] = [<span class="string">"anuj"</span>, <span class="string">"peggy"</span>]</div><div class="line">graph[<span class="string">"alice"</span>] = [<span class="string">"peggy"</span>]</div><div class="line">graph[<span class="string">"claire"</span>] = [<span class="string">"thom"</span>, <span class="string">"jonny"</span>]</div><div class="line">graph[<span class="string">"anuj"</span>] = []</div><div class="line">graph[<span class="string">"peggy"</span>] = []</div><div class="line">graph[<span class="string">"thom"</span>] = []</div><div class="line">graph[<span class="string">"jonny"</span>] = []</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(name: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">var</span> searchQueue = <span class="type">Deque</span>&lt;<span class="type">String</span>&gt;()</div><div class="line">    <span class="comment">//Swift Note: Our custom Deque doesn't have possibility to add new element as array so we have to add elements one by one (insted of +=graph["person"] in the book example)</span></div><div class="line">    <span class="keyword">for</span> string <span class="keyword">in</span> graph[name]! &#123;</div><div class="line">        searchQueue.enqueue(string)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// This array is how you keep track of which people you've searched before.</span></div><div class="line">    <span class="keyword">var</span> searched = [<span class="type">String</span>]()</div><div class="line">    <span class="keyword">while</span> !searchQueue.isEmpty &#123;</div><div class="line">        <span class="keyword">let</span> person = searchQueue.dequeue()</div><div class="line">        <span class="comment">// Only search this person if you haven't already searched them</span></div><div class="line">        <span class="keyword">if</span> !searched.<span class="built_in">contains</span>(person!) &#123;</div><div class="line">            <span class="keyword">if</span> persionIsSeller(name: person!) &#123;</div><div class="line">                <span class="built_in">print</span>(<span class="string">"<span class="subst">\(person!)</span> is a mango seller!"</span>)</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">for</span> string <span class="keyword">in</span> graph[person!]! &#123;</div><div class="line">                    searchQueue.enqueue(string)</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// Marks this person as searched</span></div><div class="line">                searched.append(person!)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> search(name: <span class="string">"you"</span>) == <span class="literal">false</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Mango seller Not Found!"</span>)</div><div class="line">&#125; <span class="comment">// =&gt; thom is a mango seller!</span></div></pre></td></tr></table></figure>
<h4 id="狄克斯特拉算法"><a href="#狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法"></a>狄克斯特拉算法</h4><p>非加权图用广度优先搜索，加权图使用狄克斯特拉算法。环增加权重，不可能是最短路径。狄克斯特拉适用于有向无环图。负权边不能用狄克斯特拉，得用<strong>贝尔曼-福德算法</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"></div><div class="line"><span class="comment">// the graph</span></div><div class="line"><span class="keyword">var</span> graph =  [<span class="type">String</span> : [<span class="type">String</span>: <span class="type">Double</span>]] ()</div><div class="line">graph[<span class="string">"start"</span>] = [<span class="type">String</span>: <span class="type">Double</span>]()</div><div class="line">graph[<span class="string">"start"</span>]?[<span class="string">"a"</span>] = <span class="number">6</span></div><div class="line">graph[<span class="string">"start"</span>]?[<span class="string">"b"</span>] = <span class="number">2</span></div><div class="line"></div><div class="line">graph[<span class="string">"a"</span>] = [<span class="type">String</span>: <span class="type">Double</span>]()</div><div class="line">graph[<span class="string">"a"</span>]?[<span class="string">"fin"</span>] = <span class="number">1</span></div><div class="line"></div><div class="line">graph[<span class="string">"b"</span>] = [<span class="type">String</span>: <span class="type">Double</span>]()</div><div class="line">graph[<span class="string">"b"</span>]?[<span class="string">"a"</span>] = <span class="number">3</span></div><div class="line">graph[<span class="string">"b"</span>]?[<span class="string">"fin"</span>] = <span class="number">5</span></div><div class="line"></div><div class="line">graph[<span class="string">"fin"</span>] = [<span class="type">String</span>: <span class="type">Double</span>]()</div><div class="line"></div><div class="line"><span class="comment">// the costs table</span></div><div class="line"><span class="keyword">let</span> infinity = <span class="type">Double</span>.infinity</div><div class="line"><span class="keyword">var</span> costs = [<span class="type">String</span>: <span class="type">Double</span>]()</div><div class="line">costs[<span class="string">"a"</span>] = <span class="number">6</span></div><div class="line">costs[<span class="string">"b"</span>] = <span class="number">2</span></div><div class="line">costs[<span class="string">"fin"</span>] = infinity</div><div class="line"></div><div class="line"><span class="comment">// the parents table</span></div><div class="line"><span class="keyword">var</span> parents = [<span class="type">String</span>: <span class="type">String</span>]()</div><div class="line">parents[<span class="string">"a"</span>] = <span class="string">"start"</span></div><div class="line">parents[<span class="string">"b"</span>] = <span class="string">"start"</span></div><div class="line">parents[<span class="string">"fin"</span>] = <span class="literal">nil</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> processed = [<span class="type">String</span>]()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLowestCostNode</span><span class="params">(costs: [String: Double])</span></span> -&gt; [<span class="type">String</span>: <span class="type">Double</span>] &#123;</div><div class="line">    <span class="keyword">var</span> lowestCost = <span class="type">Double</span>.infinity</div><div class="line">    <span class="keyword">var</span> lowestCostNode = [<span class="type">String</span>: <span class="type">Double</span>]()</div><div class="line">    <span class="comment">// Go through each node.</span></div><div class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> costs &#123;</div><div class="line">        <span class="keyword">let</span> cost = node.value</div><div class="line">        <span class="comment">// If it's the lowest cost so far and hasn't been processed yet...</span></div><div class="line">        <span class="keyword">if</span> (cost &lt; lowestCost) &amp;&amp; !processed.<span class="built_in">contains</span>(node.key) &#123;</div><div class="line">            <span class="comment">// ... set it as the new lowest-cost node.</span></div><div class="line">            lowestCost = cost</div><div class="line">            lowestCostNode = [node.key : node.value]</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> lowestCostNode</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Find the lowest-cost node that you haven't processed yet.</span></div><div class="line"><span class="keyword">var</span> node = findLowestCostNode(costs: costs)</div><div class="line"></div><div class="line"><span class="comment">// If you've processed all the nodes, this while loop is done.</span></div><div class="line"><span class="keyword">while</span> !node.isEmpty &#123;</div><div class="line">    <span class="comment">// Swift Note: Unfortunately there are some limits for working with Dictionary inside Dictionary, so we have to use temp "nodeFirstKey" variable as workaround</span></div><div class="line">    <span class="keyword">var</span> nodeFirstKey = node.first?.key</div><div class="line">    <span class="keyword">var</span> cost = costs[nodeFirstKey!]</div><div class="line">    <span class="comment">// Go through all the neighbors of this node.</span></div><div class="line">    <span class="keyword">var</span> neighbors = graph[nodeFirstKey!]</div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> (neighbors?.keys)! &#123;</div><div class="line">        <span class="keyword">var</span> newCost = cost! + (neighbors?[n])!</div><div class="line">        <span class="comment">// If it's cheaper to get to this neighbor by going through this node...</span></div><div class="line">        <span class="keyword">if</span> costs[n]! &gt; newCost &#123;</div><div class="line">            <span class="comment">// ... update the cost for this node.</span></div><div class="line">            costs[n] = newCost</div><div class="line">            <span class="comment">// This node becomes the new parent for this neighbor.</span></div><div class="line">            parents[n] = nodeFirstKey</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Mark the node as processed.</span></div><div class="line">    processed.append(nodeFirstKey!)</div><div class="line">    <span class="comment">// Find the next node to process, and loop.</span></div><div class="line">    node = findLowestCostNode(costs: costs)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"Cost from the start to each node:"</span>)</div><div class="line"><span class="built_in">print</span>(costs) <span class="comment">// -&gt; ["b": 2.0, "fin": 6.0, "a": 5.0]</span></div></pre></td></tr></table></figure>
<h4 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h4><p>每步都选择最优做法，结果与正确结果接近。集合问题的贪婪算法，O(n2)。NP完全问题，需要计算所有的解，选出最好的。NP只能求近似解，非NP能容易算出解。组合、序列、集合可能是NP完全问题，需要考虑所有情况不能分解，数量多变复杂速度变慢。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"></div><div class="line"><span class="comment">// You pass an array in, and it gets converted to a set.</span></div><div class="line"><span class="keyword">var</span> statesNeeded : <span class="type">Set</span> = [<span class="string">"mt"</span>, <span class="string">"wa"</span>, <span class="string">"or"</span>, <span class="string">"id"</span>, <span class="string">"nv"</span>, <span class="string">"ut"</span>, <span class="string">"ca"</span>, <span class="string">"az"</span>]</div><div class="line"></div><div class="line"><span class="keyword">var</span> stations = [<span class="type">String</span>: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;]()</div><div class="line">stations[<span class="string">"kone"</span>] = [<span class="string">"id"</span>, <span class="string">"nv"</span>, <span class="string">"ut"</span>]</div><div class="line">stations[<span class="string">"ktwo"</span>] = [<span class="string">"wa"</span>, <span class="string">"id"</span>, <span class="string">"mt"</span>]</div><div class="line">stations[<span class="string">"kthree"</span>] = [<span class="string">"or"</span>, <span class="string">"nv"</span>, <span class="string">"ca"</span>]</div><div class="line">stations[<span class="string">"kfour"</span>] = [<span class="string">"nv"</span>, <span class="string">"ut"</span>]</div><div class="line">stations[<span class="string">"kfive"</span>] = [<span class="string">"ca"</span>, <span class="string">"az"</span>]</div><div class="line"></div><div class="line"><span class="keyword">var</span> finalStations = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;();</div><div class="line"></div><div class="line"><span class="keyword">while</span> !statesNeeded.isEmpty &#123;</div><div class="line">    <span class="keyword">var</span> bestStation = <span class="type">String</span>()</div><div class="line">    <span class="keyword">var</span> statesCovered = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> station <span class="keyword">in</span> stations &#123;</div><div class="line">        <span class="keyword">var</span> covered = statesNeeded.intersection(station.value)</div><div class="line">        <span class="keyword">if</span> covered.<span class="built_in">count</span> &gt; statesCovered.<span class="built_in">count</span> &#123;</div><div class="line">            bestStation = station.key</div><div class="line">            statesCovered = covered</div><div class="line">        &#125;</div><div class="line">        statesNeeded = statesNeeded.subtracting(statesCovered)</div><div class="line">        <span class="comment">//Swift note: We should avoid adding empty station to Set</span></div><div class="line">        <span class="keyword">if</span> !bestStation.isEmpty &#123;</div><div class="line">            finalStations.insert(bestStation)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(finalStations) <span class="comment">// -&gt; ["kone", "kfive", "ktwo", "kthree"]</span></div></pre></td></tr></table></figure>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>求最优解，画网格图。依赖于子问题是离散的。应用，DNA相似性、git、diff、拼写检查等。</p>
<h4 id="K最近邻算法"><a href="#K最近邻算法" class="headerlink" title="K最近邻算法"></a>K最近邻算法</h4><p>KNN，分类和回归，分类就是编组，回归是预测。余弦相似度，计算矢量距离。KNN用于机器学习，OCR，人脸识别，语音识别。训练数据。朴素贝叶斯分类器预测垃圾邮件概率。</p>
<h4 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h4><p>二叉查找树，O(logn),插入删除也快，不能随机访问。B树、红黑树、堆、伸展树。搜索引擎，反向索引。傅里叶变换，压缩音视频，地震预测、DNA分析。并行算法。MapReduce,分布式算法，短时间内完成海量工作。布隆过滤器是概率性数据结构，答案不一定准确，占用存储空间小。SHA，根据字符串返回散列值，比较文件，检查密码，simhash，局部敏感，检查相似程度，如论文查重。RSA加密。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-06-03</span><i class="fa fa-comment-o"></i><a href="/2017/06/03/算法入门【算法图解】/#comments">评论</a><i class="fa fa-tag"></i><a href="/tags/图书/" title="图书" class="tag">图书 </a><a href="/tags/专业技术/" title="专业技术" class="tag">专业技术 </a><a href="/tags/算法/" title="算法" class="tag">算法 </a></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,https://amasawaseiji.github.io/2017/06/03/算法入门【算法图解】/,思过崖,算法入门【算法图解】,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/06/04/茅庐【两晋风云】/" title="茅庐【两晋风云】" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/05/31/初读【红楼梦】/" title="初读【红楼梦】" class="btn">下一篇</a></li></ul></div><a id="comments"></a><div data-thread-key="2017/06/03/算法入门【算法图解】/" data-title="算法入门【算法图解】" data-url="https://amasawaseiji.github.io/2017/06/03/算法入门【算法图解】/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"amasawaseiji"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>